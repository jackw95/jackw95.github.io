I"<ul id="markdown-toc">
  <li><a href="#03--事务隔离为什么你改了我还看不见" id="markdown-toc-03--事务隔离为什么你改了我还看不见">03 | 事务隔离：为什么你改了我还看不见？</a></li>
  <li><a href="#事务" id="markdown-toc-事务">事务</a></li>
</ul>

<h3 id="03--事务隔离为什么你改了我还看不见">03 | 事务隔离：为什么你改了我还看不见？</h3>

<h3 id="事务">事务</h3>

<p><strong>保证一组数据库操作，要么全部成功，要么全部失败。</strong></p>

<p><strong><code class="highlighter-rouge">ACID</code>特性</strong></p>
<ul>
  <li>原子性：<code class="highlighter-rouge">Atomicity</code></li>
  <li>一致性：<code class="highlighter-rouge">Consistency</code></li>
  <li>隔离性：<code class="highlighter-rouge">Isolation</code></li>
  <li>持久性：<code class="highlighter-rouge">Durability</code></li>
</ul>

<p>当数据库中有多个事务同时执行的时候，就可能出现脏读（<code class="highlighter-rouge">dirty read</code>）、不可重复读（<code class="highlighter-rouge">non-repeatable read</code>）、幻读（<code class="highlighter-rouge">phantom read</code>）的问题，为了解决这些问题，就有了“隔离级别”的概念。隔离的越严实，效率就会越低，需要在两者之间找一个平衡点。</p>

<p><strong>事务隔离级别</strong><br />
隔离级别：串行化 &gt; 可重复读 &gt; 读提交 &gt; 读未提交</p>

<ul>
  <li>读未提交：<code class="highlighter-rouge">read uncommitted</code>，一个事务还没提交时，它做的变更就能被别的事务看到。会导致“脏读”、“幻读”、“不可重复读”。</li>
  <li>读提交：<code class="highlighter-rouge">read committed</code>，一个事务提交之后，它做的变更才会被其他事务-看到。避免了“脏读”，但不能避免“幻读”和“不可重复读”。</li>
  <li>可重复读：<code class="highlighter-rouge">repeatable read</code>，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据时一致的。当然在可重复读的隔离级别下，未提交变更对其他事务也是不可见的，<code class="highlighter-rouge">MySQL</code>的默认级别。 避免了“脏读”和“不可重复读”，但不能避免“幻读”。</li>
  <li>串行化：<code class="highlighter-rouge">serializable</code>，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。能比秒“脏读”、“幻读”、“可重复读”。</li>
</ul>

<p><strong>不同事务级别带来的并发问题</strong></p>
<ul>
  <li>脏读：读取到了别的事务回滚前的脏数据。事务A读取了被另一个事务B修改，但是还未提交的数据。假如事务B回退，则事务A读取的是无效数据。</li>
  <li>不可重复读：当前事务进行了一次数据读取，然后再次读取的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配</li>
  <li>幻读：当两个完全相同的查询执行时，第二次查询所返回的结果集和第一个查询的不相同。</li>
</ul>
:ET