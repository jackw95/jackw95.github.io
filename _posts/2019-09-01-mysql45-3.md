---
layout: post
title:  "事务隔离"
date:   2019-09-01
categories: MySQL实战45讲
tags: mysql
---

* content
{:toc}

### 03 | 事务隔离：为什么你改了我还看不见？

### 事务

**保证一组数据库操作，要么全部成功，要么全部失败。**

**`ACID`特性**
- 原子性：`Atomicity`
- 一致性：`Consistency`
- 隔离性：`Isolation`
- 持久性：`Durability`

当数据库中有多个事务同时执行的时候，就可能出现脏读（`dirty read`）、不可重复读（`non-repeatable read`）、幻读（`phantom read`）的问题，为了解决这些问题，就有了“隔离级别”的概念。隔离的越严实，效率就会越低，需要在两者之间找一个平衡点。

**事务隔离级别**  
隔离级别：串行化 > 可重复读 > 读提交 > 读未提交

- 读未提交：`read uncommitted`，一个事务还没提交时，它做的变更就能被别的事务看到。会导致“脏读”、“幻读”、“不可重复读”。 
- 读提交：`read committed`，一个事务提交之后，它做的变更才会被其他事务-看到。避免了“脏读”，但不能避免“幻读”和“不可重复读”。
- 可重复读：`repeatable read`，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据时一致的。当然在可重复读的隔离级别下，未提交变更对其他事务也是不可见的，`MySQL`的默认级别。 避免了“脏读”和“不可重复读”，但不能避免“幻读”。
- 串行化：`serializable`，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。能比秒“脏读”、“幻读”、“可重复读”。


**不同事务级别带来的并发问题**
- 脏读：读取到了别的事务回滚前的脏数据。事务A读取了被另一个事务B修改，但是还未提交的数据。假如事务B回退，则事务A读取的是无效数据。
- 不可重复读：当前事务进行了一次数据读取，然后再次读取的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配
- 幻读：当两个完全相同的查询执行时，第二次查询所返回的结果集和第一个查询的不相同。
