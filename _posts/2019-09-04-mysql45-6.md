---
layout: post
title:  "全局锁和表锁"
date:   2019-09-04
categories: MySQL实战45讲
tags: mysql
excerpt: 给表加个字段怎么有这么多阻碍？
---

* content
{:toc}
 
 ### 06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？

数据库锁的初衷：处理并发问题
- 全局锁
- 表锁
- 行锁

全局锁：对整个数据库实例加锁。`MySQL`提供了一个加全局读锁的方法（FTWRL），`Flush tables with read lock`，之后整个数据库处于读锁状态。
使用场景：全库逻辑备份，就是说把整库每个表都select出来存成文本。

这个库变成只读状态后：
- 如果在主库上备份，备份期间都不能执行更新，业务基本上就得停摆
- 在从库上备份，备份期间从库不能执行主库同步过来的`binlog`，导致主从延迟。

表级锁：对整个表进行加锁。加锁`lock tables xxx read/write`，释放锁`unlock tables xxx`，客户端断开的时候也会自动释放表锁。注意：lock tables语法除了会限制别的线程的读写外，也限制了本线程接下来的操作对象。
在线程A中使用`lock tables t1 read, t2 write`后，其他线程写t1，读写t2都会被阻塞，同时，线程A在执行`unlock tables`之前，只能执行读t1，读写t2的操作。




- 共享锁：读锁，共享，互不阻塞，多个客户在同一时刻可以读取同一个资源，而互不干扰
- 排他锁：写锁，排他，一个写锁会阻塞其他的写锁和读锁。

排他锁，能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

`MySQL`锁粒度
- 表锁。`MySQL`最基本的锁策略，也是开销最小的策略。
    会锁定整张表，一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，它会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间互不阻塞。
- 行锁。最大程度地支持并发处理（同时也带来了最大锁开销）。行级锁只在存储引擎层实现，在Server层没有实现。
- 

注：在`MySQL`的`information_schema`库的`innodb_trx`表中，可以查到当前执行的事务。